
'use server';

/**
 * @fileOverview An AI tool that intelligently merges two weekly study plans into a single, cohesive schedule.
 *
 * - mergeWeeklyPlans - A function that combines an existing weekly study plan and a new one.
 * - MergeWeeklyPlansInput - The input type for the mergeWeeklyPlans function.
 * - MergeWeeklyPlansOutput - The return type for the mergeWeeklyPlans function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import { DayOfWeek } from '@/lib/types';


const StudyPlanItemSchema = z.object({
    id: z.string(),
    day: z.nativeEnum(DayOfWeek),
    time: z.string().describe("Suggested time slot, e.g., '15:00 - 17:00'"),
    course: z.string().describe("The name of the course to study."),
    activity: z.string().describe("A brief suggestion for the study activity, e.g., 'Review lecture notes' or 'Problem set'"),
});


const MergeWeeklyPlansInputSchema = z.object({
  existingPlan: z.array(StudyPlanItemSchema).describe('The userâ€™s current weekly study plan.'),
  newPlan: z.array(StudyPlanItemSchema).describe('The new plan generated by the AI that needs to be merged.'),
});
export type MergeWeeklyPlansInput = z.infer<typeof MergeWeeklyPlansInputSchema>;

const MergeWeeklyPlansOutputSchema = z.object({
  mergedPlan: z.array(StudyPlanItemSchema.omit({id: z.any()})).describe('A single, cohesive, and chronologically sorted list of study activities for the week.'),
});
export type MergeWeeklyPlansOutput = z.infer<typeof MergeWeeklyPlansOutputSchema>;

export async function mergeWeeklyPlans(input: MergeWeeklyPlansInput): Promise<MergeWeeklyPlansOutput> {
  return mergeWeeklyPlansFlow(input);
}

const prompt = ai.definePrompt({
  name: 'mergeWeeklyPlansPrompt',
  input: { schema: MergeWeeklyPlansInputSchema },
  output: { schema: MergeWeeklyPlansOutputSchema },
  prompt: `You are a master scheduler AI. Your task is to intelligently merge two weekly study plans into a single, cohesive, and chronologically sorted schedule.

  Rules:
  1.  **Resolve Conflicts:** If there are overlapping time slots for the same day, prioritize the item from the "new plan" as it represents a more recent intention. Adjust surrounding flexible tasks if necessary.
  2.  **Combine Similar Activities:** If both plans have similar study blocks for the same course on the same day, try to combine them into a single, logical entry.
  3.  **Maintain Chronological Order:** The final merged plan must be sorted by day, and then by time within each day.
  4.  **Do Not Drop Important Items:** Ensure all unique and important study blocks from both plans are included in the final output. If two items are on the same day at the same time, the one from the "new plan" takes precedence.
  5.  **Be Logical:** Create a schedule that flows naturally and is realistic for a student.

  **Existing Plan:**
  {{#each existingPlan}}
  - {{this.day}} {{this.time}}: Study {{this.course}} ({{this.activity}})
  {{/each}}

  **New Plan to Merge:**
  {{#each newPlan}}
  - {{this.day}} {{this.time}}: Study {{this.course}} ({{this.activity}})
  {{/each}}

  Generate the merged plan now. The output items should not have an 'id' field.
  `,
});

const mergeWeeklyPlansFlow = ai.defineFlow(
  {
    name: 'mergeWeeklyPlansFlow',
    inputSchema: MergeWeeklyPlansInputSchema,
    outputSchema: MergeWeeklyPlansOutputSchema,
  },
  async (input) => {
    const maxRetries = 3;
    let attempt = 0;
    while (attempt < maxRetries) {
      try {
        const { output } = await prompt(input);
        return output!;
      } catch (error: any) {
        attempt++;
        if (attempt >= maxRetries) {
          console.error('Final attempt failed:', error);
          throw new Error('The AI model is currently overloaded. Please try again in a few moments.');
        }
        console.log(`Attempt ${attempt} failed. Retrying in 2 seconds...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    throw new Error('The AI model failed to respond after multiple attempts.');
  }
);
